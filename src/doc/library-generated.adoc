
////

File automatically generated, do not edit

////


== conf




---


:sectnums!:

[[lib.conf.mergeConfs]]
=== mergeConfs

==== Description

Merge a list of configurations.


==== Arguments (Standard)


===== confs

List of configurations.

Type: `[ Attrs | Path ]`. 

==== Return

The merged configuration set.





:sectnums:



---


:sectnums!:

[[lib.conf.parseDecls]]
=== parseDecls

==== Description

Parse configuration interface declarations.


==== Arguments (Attribute Set)


===== decls

A configuration attribute set.

Type: `Attrs`. 

===== optionFn

Function to convert options.

Type: `Option -> a`. 

Optional, defaults to `lib.id`.

===== valueFn

Function to convert values.

Type: `a -> b`. 

Optional, defaults to `lib.id`.

==== Return

`Attrs`

==== Example


[source, nix]
.Code
----
parseDecls {
  optionFn = o: option.default;
  valueFn  = v: v + 1;
  decls = {
    a.b.c = mkOption {
      default = "abc";
      type = types.str;
    };
    x.y = 1;
  };
}

----

[source, nix]
.Result
----
{
  a = {
    b = {
      c = "abc";
    };
  };
  x = {
    y = 2;
  };
}
----






:sectnums:



---


:sectnums!:

[[lib.conf.typeCheck]]
=== typeCheck

==== Description

Type check configuration declarations against definitions.


==== Arguments (Standard)


===== decls

A configuration declarations attribute set.

Type: `Attrs`. 

===== defs

A configuration definitions attribute set.

Type: `Attrs`. 

==== Return

Throw an error if `defs` do not type-check with `decls`.





:sectnums:



---




== data

The data namespace contains functions to fetch and manipulate data.



---


:sectnums!:

[[lib.data.asciidocToHtml]]
=== asciidocToHtml

==== Description

Convert asciidoc text to HTML.

==== Arguments (Standard)


===== text

Text in asciidoc format.

Type: `String`. 

==== Return

`String`

==== Example


[source, nix]
.Code
----
asciidocToHtml "Hello `asciidoc`!"

----

[source, nix]
.Result
----
"<div class=\"paragraph\">
<p>Hello <code>asciidoc</code>!</p>
</div>
"
----






:sectnums:



---


:sectnums!:

[[lib.data.groupBy]]
=== groupBy

==== Description

Group a list of attribute sets.

==== Arguments (Standard)


===== list

List of attribute sets.

Type: `[ Attrs ]`. 

===== f

Function to generate the group name.

Type: `Attrs -> String`. 

==== Return

A property list of grouped attribute sets

==== Example


[source, nix]
.Code
----
groupBy [
  { type = "fruit"; name = "apple"; }
  { type = "fruit"; name = "pear"; }
  { type = "vegetable"; name = "lettuce"; }
]
(s: s.type)

----

[source, nix]
.Result
----
[ {
  fruit = [ {
    name = "apple";
    type = "fruit";
  } {
    name = "pear";
    type = "fruit";
  } ];
} {
  vegetable = [ {
    name = "lettuce";
    type = "vegetable";
  } ];
} ]
----






:sectnums:



---


:sectnums!:

[[lib.data.loadDir]]
=== loadDir

==== Description

Load a directory containing data that styx can handle.


==== Arguments (Attribute Set)


===== asAttrs

If set to true, the function will return a set instead of a list. The key will be the file basename, and the value the data set.

Type: `Bool`. 

Optional, defaults to `false`.

===== dir

The directory to load data from.

Type: `Path`. 

===== env

The nix environment to use in loaded files.

Type: `Attrs`. 

Optional, defaults to `{ }`.

===== filterDraftsFn

Function to filter the drafts.

Type: `Draft -> Bool`. 

Optional, defaults to `d: !( ( !(attrByPath ["conf" "renderDrafts"] false env) ) && (attrByPath ["draft"] false d) )`.

==== Return

A list of data attribute sets. (Or a set of data set if `asAttrs` is `true`)

==== Example


[source, nix]
.Code
----
data.posts = loadDir {
  dir = ./data/posts;
  inherit env;
};

----




[NOTE]
====
Any extra attribute in the argument set will be added to every loaded data attribute set.

====


:sectnums:



---


:sectnums!:

[[lib.data.loadFile]]
=== loadFile

==== Description

Loads a data file

==== Arguments (Attribute Set)


===== env

The nix environment to use in loaded file.

Type: `Attrs`. 

Optional, defaults to `{ }`.

===== file

Path of the file to load.

Type: `Path`. 

==== Return

A list of data attribute sets. (Or a set of data set if `asAttrs` is `true`)

==== Example


[source, nix]
.Code
----
data.posts = loadFile {
  file = ./data/pages/about.md;
  inherit env;
};

----




[NOTE]
====
Any extra attribute in the argument set will be added to the data attribute set.

====


:sectnums:



---


:sectnums!:

[[lib.data.markdownToHtml]]
=== markdownToHtml

==== Description

Convert markdown text to HTML.

==== Arguments (Standard)


===== text

Text in markdown format

Type: `String`. 

==== Return

`String`

==== Example


[source, nix]
.Code
----
markdownToHtml "Hello `markdown`!"

----

[source, nix]
.Result
----
"<p>Hello <code>markdown</code>!</p>
"
----






:sectnums:



---


:sectnums!:

[[lib.data.mkTaxonomyData]]
=== mkTaxonomyData

==== Description

Generate taxonomy data from a list of data attribute sets.


==== Arguments (Attribute Set)


===== Taxonomies

A list of taxonomies to extract.

Type: `[ String ]`. 

===== data

A list of data attribute sets to extract taxonomy data from.

Type: `[ Data ]`. 

==== Return

A taxonomy attribute set.

==== Example


[source, nix]
.Code
----
mkTaxonomyData {
  data = [
    { tags = [ "foo" "bar" ]; path = "/a.html"; }
    { tags = [ "foo" ];       path = "/b.html"; }
    { category = [ "baz" ];   path = "/c.html"; }
  ];
  taxonomies = [ "tags" "category" ];
}

----

[source, nix]
.Result
----
[ {
  category = [ {
    baz = [ {
      category = [ "baz" ];
      path = "/c.html";
    } ];
  } ];
} {
  tags = [ {
    foo = [ {
      path = "/b.html";
      tags = [ "foo" ];
    } {
      path = "/a.html";
      tags = [ "foo" "bar" ];
    } ];
  } {
    bar = [ {
      path = "/a.html";
      tags = [ "foo" "bar" ];
    } ];
  } ];
} ]
----






:sectnums:



---


:sectnums!:

[[lib.data.sortTerms]]
=== sortTerms

==== Description

Sort taxonomy terms by number of occurences.

==== Arguments (Standard)


===== terms

List of taxonomy terms attribute sets.

Type: `[ Terms ]`. 

==== Return

Sorted list of taxonomy terms attribute sets.

==== Example


[source, nix]
.Code
----
sortTerms [ { bar = [ {} {} ]; } { foo = [ {} {} {} ]; } ]

----

[source, nix]
.Result
----
[ {
  foo = [ { } { } { } ];
} {
  bar = [ { } { } ];
} ]
----






:sectnums:



---


:sectnums!:

[[lib.data.valuesNb]]
=== valuesNb

==== Description

Calculate the number of values in a taxonomy term attribute set.

==== Arguments (Standard)


===== term

Taxonomy terms attribute set.

Type: `Terms`. 

==== Return

`Int`

==== Example


[source, nix]
.Code
----
valuesNb { foo = [ {} {} {} ]; }

----

[source, nix]
.Result
----
3
----






:sectnums:



---




== generation




---


:sectnums!:

[[lib.generation.generatePage]]
=== generatePage

==== Description

Function to generate a page source, used by `mkSite`.

==== Arguments (Standard)


===== page

A page attribute set with at least `layout` and `template` defined.

Type: `Page`. 

==== Return

Page source

==== Example


[source, nix]
.Code
----
generatePage {
  layout = template: "<html><body>${template}</body></html>";
  template = page: ''
    <h1>Styx example page</h1>
    ${page.content}
  '';
  content = "<p>Hello world!</p>";
};

----

[source, nix]
.Result
----
"<html><body><h1>Styx example page</h1>
<p>Hello world!</p>
</body></html>"
----






:sectnums:



---


:sectnums!:

[[lib.generation.localesToPageList]]
=== localesToPageList

==== Description

Convert a set of locales to a list of pages.

==== Arguments (Attribute Set)


===== default

A function to set default values to the pages, eg: to set the default `layout` template.

Type: `Locale -> Attrs`. 

Optional, defaults to `locale: {}`.

===== locales

A set of locales, each having a `pages` attribute set.

Type: `Attrs`. 

==== Return

`[ Page ]`

==== Example


[source, nix]
.Code
----
pagelist = localesToPageList {
  inherit locales;
  default = locale: {
    layout = locale.env.templates.layout;
  };
};

----



---

[source, nix]
.Code
----
localesToPageList {
  locales = {
    eng = rec { 
      code   = "eng";
      prefix = "/${code}";
      pages = {
        foo = { path = "/foo.html"; };
        bar = [ { path = "/bar-1.html"; } { path = "/bar-2.html"; } ];
      };
    };
    fre = rec {
      code = "fre";
      prefix = "/${code}";
      pages = {
        foo = { path = prefix + "/foo.html"; };
        bar = [ { path = prefix + "/bar-1.html"; } { path = prefix + "/bar-2.html"; } ];
      };
    };
  };
  default = locale: {
    baz = "${locale.code}-baz";
  };
}

----

[source, nix]
.Result
----
[ {
  baz = "eng-baz";
  path = "/foo.html";
} {
  baz = "eng-baz";
  path = "/bar-1.html";
} {
  baz = "eng-baz";
  path = "/bar-2.html";
} {
  baz = "fre-baz";
  path = "/fre/foo.html";
} {
  baz = "fre-baz";
  path = "/fre/bar-1.html";
} {
  baz = "fre-baz";
  path = "/fre/bar-2.html";
} ]
----






:sectnums:



---


:sectnums!:

[[lib.generation.mkSite]]
=== mkSite

==== Description

Generate a site, this is the main function of a styx site.

==== Arguments (Attribute Set)


===== files

A list of static files directories to copy in the site.

Type: `[ Path ]`. 

Optional, defaults to `[  ]`.

===== genPageFn

Function to generate a page source from a page attribute set.

Type: `Page -> String`. 

Optional, defaults to `lib.generation.generatePage`.

===== meta

Meta attribute set of the generated site derivation.

Type: `Attrs`. 

Optional, defaults to `{ }`.

===== pageList

A list of pages attributes sets to generate.

Type: `[ Page ]`. 

Optional, defaults to `[  ]`.

===== pagePathFn

Function to generate a page from a page attribute set.

Type: `Page -> String`. 

Optional, defaults to `page: page.path`.

===== postGen

A set of command to execute after generating the site.

Type: `String`. 

Optional, defaults to `""`.

===== preGen

A set of command to execute before generating the site.

Type: `String`. 

Optional, defaults to `""`.

===== substitutions

A substitution set to apply to static files.

Type: `Attrs`. 

Optional, defaults to `{ }`.

==== Return

The site derivation.

==== Example


[source, nix]
.Code
----
mkSite { pageList = [ pages.index ]; }

----






:sectnums:



---


:sectnums!:

[[lib.generation.pagesToList]]
=== pagesToList

==== Description

Convert a set of pages to a list of pages.

==== Arguments (Attribute Set)


===== default

Attribute set of default values to add to every page set, useful to set `layout`.

Type: `Attrs`. 

Optional, defaults to `{ }`.

===== pages

A set of page attribute sets.

Type: `Attrs`. 

==== Return

`[ Page ]`

==== Example


[source, nix]
.Code
----
pagelist = pagestolist {
  inherit pages;
  default.layout = templates.layout;
};

----



---

[source, nix]
.Code
----
pagesToList {
  pages = {
    foo = { path = "/foo.html"; };
    bar = [ { path = "/bar-1.html"; } { path = "/bar-2.html"; } ];
  };
  default = {
    baz = "baz";
  };
}

----

[source, nix]
.Result
----
[ {
  baz = "baz";
  path = "/foo.html";
} {
  baz = "baz";
  path = "/bar-1.html";
} {
  baz = "baz";
  path = "/bar-2.html";
} ]
----






:sectnums:



---




== pages




---


:sectnums!:

[[lib.pages.mkMultipages]]
=== mkMultipages

==== Description

Create the list of pages from a multipage data set.

==== Arguments (Attribute Set)


===== basePath

String used by `pathFn` to generate the page path. Used in `pageFn` default, ignored if `pageFn` is set.

Type: `String`. 

Optional, defaults to `null`.

===== pageFn

Function to generate extra attributes to merge to the page.

Type: `Int -> Data -> Page`. 

Optional, defaults to:

[source, nix]
----
index: data:
  optionalAttrs (basePath != null) {
    path = mkSplitPagePath { inherit index; pre = basePath; };
  }

----


===== pages

List of subpages data.

Type: `[ Attrs ]`. 

==== Return

Pages according to the `output`. +
Every page will get a `multipages` attribute containing:

- `pages`: list of all the subpages.
- `index`: Index of the page in the `subpages` list.



==== Example


[source, nix]
.Code
----
pages.about = mkMultipages ({
  template = templates.page.full;
  basepath = "about";
} // data.about);

----



---


[NOTE]
====
Any extra arguments will be forwarded to every generated page set.

====


:sectnums:



---


:sectnums!:

[[lib.pages.mkPageList]]
=== mkPageList

==== Description

Generate a list of pages from a list of data set.

==== Arguments (Attribute Set)


===== data

List of data sets.

Type: `[ Data ]`. 

===== multipageFn

Function to generate extra attributes of mutipages.

Type: `Int -> Data -> Attrs`. 

Optional, defaults to:

[source, nix]
----
index: data: {
  path = mkSplitPagePath { pre = "${pathPrefix}${data.fileData.basename}"; inherit index; };
}

----


===== pageFn

Function to generate extra attributes of normal pages.

Type: `(Data -> Attrs)`. 

Optional, defaults to `data: { path = "${pathPrefix}${data.fileData.basename}.html"; }`.

===== pathPrefix

String used by `pathFn` and `multipagePathFn` to generate the page path.

Type: `String`. 

Optional, defaults to `""`.

==== Return

An attribute set with the following attributes:.

- `list`: The list of contents, containing single pages and first page of multipages posts.
- `pages`: List of all pages, including multipages subpages.


==== Example


[source, nix]
.Code
----
pages.posts = mkPageList {
  data       = data.posts;
  pathPrefix = "/posts/";
  template   = templates.post.full;
};

----



---


[NOTE]
====
* Any extra arguments will be forwarded to every generated page set.

====


:sectnums:



---


:sectnums!:

[[lib.pages.mkPages]]
=== mkPages

==== Description

Generate a pages attribute set. It is used to produce multiple "outputs" by pages generating functions like `mkPageList`. +
`pagesToList` will only generate the `pages` attribute from a pages attribute set.


==== Arguments (Attribute Set)


===== pages

List of pages to generate.

Type: `[ Page ]`. 

==== Return

A pages attribute set.


[NOTE]
====
Any extra argument will be added to the pages set.

====


:sectnums:



---


:sectnums!:

[[lib.pages.mkSplit]]
=== mkSplit

==== Description

Create a list of pages from a list of data.

==== Arguments (Attribute Set)


===== basePath

Base path of the generated pages. First page path will be "``basePath``.html", follwing pages "``basePath``-``index``.html"


Type: `Attrs`. 

===== data

List of data sets.

Type: `[ Data ]`. 

===== itemsPerPage

Number of data items to allocate to a page.


Type: `Int`. 

==== Return

List of pages. Each page has:

* `items`: List of the page data items.
* `pages`: List of splitted pages.


==== Example


[source, nix]
.Code
----
pages.archives = mkSplit {
  basePath     = "/archives";
  itemsPerPage = 10;
  data         = pages.posts;
  template     = templates.archives;
};

----



---

[source, nix]
.Code
----
mkSplit {
  data = map (x: { id = x; }) (range 1 4);
  itemsPerPage = 2;
  basePath = "/test";
}

----

[source, nix]
.Result
----
[ {
  index = 1;
  items = [ {
    id = 1;
  } {
    id = 2;
  } ];
  pages = [ ... ];
  path = "/test.html";
} {
  index = 2;
  items = [ {
    id = 3;
  } {
    id = 4;
  } ];
  pages = [ ... ];
  path = "/test-2.html";
} ]
----




[NOTE]
====
Any extra arguments will be forwarded to every generated page set.

====


:sectnums:



---


:sectnums!:

[[lib.pages.mkSplitCustom]]
=== mkSplitCustom

==== Description

Create a list of pages from a list of data.

==== Arguments (Attribute Set)


===== data

List of data sets.

Type: `[ Data ]`. 

===== pageFn

A function to apply to each data set, takes the index of the page and a data set and return a page set. +
Must set `itemsNb`, the number of item to have on the page, and `path` to generate valid pages.


Type: `Int -> Data -> Page`. 

Example:

[source, nix]
----
index: data: {
  itemsNb = if index == 1 then 3 else 5;
  path = if index == 1 then "/index.html" else "/archive-${toString index}.html";
}

----


==== Return

List of pages. Each page has:

* `items`: List of the page data items.
* `pages`: List of splitted pages.


==== Example


[source, nix]
.Code
----
mkSplitCustom {
  data = map (x: { id = x; }) (range 1 4);
  pageFn = (index: data: {
    itemsNb = if index == 1 then 3 else 5;
    path    = if index == 1 then "/index.html" else "/archive-${toString index}.html";
  });
}

----

[source, nix]
.Result
----
[ {
  index = 1;
  items = [ {
    id = 1;
  } ];
  pages = [ ... ];
  path = "/index.html";
} {
  index = 2;
  items = [ {
    id = 2;
  } {
    id = 3;
  } ];
  pages = [ ... ];
  path = "/archive-2.html";
} {
  index = 3;
  items = [ {
    id = 4;
  } ];
  pages = [ ... ];
  path = "/archive-3.html";
} ]
----






:sectnums:



---


:sectnums!:

[[lib.pages.mkSplitPagePath]]
=== mkSplitPagePath

==== Description

Function to generate a splitted page path.

==== Arguments (Attribute Set)


===== index

Index of the page.

Type: `Int`. 

===== post

String to add at the end of the path.

Type: `String`. 

Optional, defaults to `".html"`.

===== pre

String to add at the beginning of the path.

Type: `String`. 

==== Return

Page path.

==== Example


[source, nix]
.Code
----
mkSplitPagePath {
  index = 1;
  pre = "/foo";
}

----

[source, nix]
.Result
----
"/foo.html"
----



---

[source, nix]
.Code
----
mkSplitPagePath {
  index = 3;
  pre = "/foo";
}

----

[source, nix]
.Result
----
"/foo-3.html"
----






:sectnums:



---


:sectnums!:

[[lib.pages.mkTaxonomyPages]]
=== mkTaxonomyPages

==== Description

Generate taxonomy pages from a data set list.

==== Arguments (Attribute Set)


===== data

List of data sets.

Type: `[ Data ]`. 

===== taxonomyPageFn

Function to add extra attributes to the taxonomy page set.

Type: `(String -> Page)`. 

Optional, defaults to `taxonomy: {}`.

===== taxonomyTemplate

Template used for taxonomy pages.

Type: `Null | Template`. 

===== termPageFn

Function to add extra attributes to the taxonomy page set.

Type: `(String -> String -> Page)`. 

Optional, defaults to `taxonomy: term: {}`.

===== termTemplate

Template used for taxonomy term pages.

Type: `Null | Template`. 

==== Return

List of taxonomy page attribute sets.

==== Example


[source, nix]
.Code
----
pages.postTaxonomies = mkTaxonomyPages {
  data = data.taxonomies.posts;
  taxonomyTemplate = templates.taxonomy.full;
  termTemplate = templates.taxonomy.term.full;
};

----






:sectnums:



---


:sectnums!:

[[lib.pages.mkTaxonomyPath]]
=== mkTaxonomyPath

==== Description

Generate a taxonomy page path.

==== Arguments (Standard)


===== taxonomy

Type: `String`. 

==== Return

Taxonomy page path.

==== Example


[source, nix]
.Code
----
mkTaxonomyPath "tags"

----

[source, nix]
.Result
----
"/tags/index.html"
----






:sectnums:



---


:sectnums!:

[[lib.pages.mkTaxonomyTermPath]]
=== mkTaxonomyTermPath

==== Description

Generate a taxonomy term page path.

==== Arguments (Standard)


===== taxonomy

Type: `String`. 

===== term

Type: `String`. 

==== Return

Taxonomy term page path.

==== Example


[source, nix]
.Code
----
mkTaxonomyTermPath "tags" "styx"

----

[source, nix]
.Result
----
"/tags/styx/index.html"
----






:sectnums:



---




== proplist

The proplist namespace contains functions to manipulate property lists, list of attribute set with only one attribute.

Property lists are used in the taxonomy data structure.

Example:

[source, nix]
----
[ { type = "fruit"; } { name = "Apple"; } ]
----



---


:sectnums!:

[[lib.proplist.getProp]]
=== getProp

==== Description

Get a property in a property list by the key name.

==== Arguments (Standard)


===== key

Key of the property to extract.

Type: `String`. 

===== proplist

The property list to extract the property from.

Type: `PropList`. 

==== Return

`Property`

==== Example


[source, nix]
.Code
----
getProp "name" [ { name = "Alice"; } ]

----

[source, nix]
.Result
----
{
  name = "Alice";
}
----






:sectnums:



---


:sectnums!:

[[lib.proplist.getValue]]
=== getValue

==== Description

Get a value from a property in a property list by the key name.

==== Arguments (Standard)


===== key

Key of the property to extract value.

Type: `String`. 

===== proplist

The property list to extract the value from.

Type: `PropList`. 

==== Return

The value of the property.

==== Example


[source, nix]
.Code
----
getValue "name" [ { name = "Alice"; } ]

----

[source, nix]
.Result
----
"Alice"
----






:sectnums:



---


:sectnums!:

[[lib.proplist.isDefined]]
=== isDefined

==== Description

Check if a property with a key exists in a property list.

==== Arguments (Standard)


===== key

Key of the property to check existence.

Type: `String`. 

===== proplist

The property list to check.

Type: `PropList`. 

==== Return

`Bool`

==== Example


[source, nix]
.Code
----
isDefined "name" [ { name = "Alice"; } ]

----

[source, nix]
.Result
----
true
----






:sectnums:



---


:sectnums!:

[[lib.proplist.propFlatten]]
=== propFlatten

==== Description

Flatten a property list which values are lists.

==== Arguments (Standard)


===== proplist

The property list to flatten.

Type: `PropList`. 

==== Return

The flattened property list.

==== Example


[source, nix]
.Code
----
propFlatten [ { foo = [ 1 2 ]; } { bar = "baz"; } { foo = [ 3 4 ]; } ]

----

[source, nix]
.Result
----
[ {
  foo = [ 1 2 3 4 ];
} {
  bar = "baz";
} ]
----






:sectnums:



---


:sectnums!:

[[lib.proplist.propKey]]
=== propKey

==== Description

Get the key of a property.

==== Arguments (Standard)


===== prop

The property to extract the key from.

Type: `Property`. 

==== Return

Key of the property.

==== Example


[source, nix]
.Code
----
propKey { name = "Alice"; }

----

[source, nix]
.Result
----
"name"
----






:sectnums:



---


:sectnums!:

[[lib.proplist.propMap]]
=== propMap

==== Description

Map for property lists.

==== Arguments (Standard)


===== f

Function to map to the property list.

Type: `PropKey -> PropValue -> a`. 

===== proplist

The property list to map.

Type: `PropList`. 

==== Return

`[ a ]`

==== Example


[source, nix]
.Code
----
propMap (k: v: "${k}: ${v}") [ { name = "Alice"; } { hobby = "Sports"; } ]

----

[source, nix]
.Result
----
[ "name: Alice" "hobby: Sports" ]
----






:sectnums:



---


:sectnums!:

[[lib.proplist.propValue]]
=== propValue

==== Description

Get the value of a property.

==== Arguments (Standard)


===== prop

The property to extract the value from.

Type: `Property`. 

==== Return

The value of the property.

==== Example


[source, nix]
.Code
----
propValue { name = "Alice"; }

----

[source, nix]
.Result
----
"Alice"
----






:sectnums:



---


:sectnums!:

[[lib.proplist.removeProp]]
=== removeProp

==== Description

Return a property list where the property with key `key` has been removed.

==== Arguments (Standard)


===== key

Key of the property to remove.

Type: `String`. 

===== proplist

The property list to remove the property from.

Type: `PropList`. 

==== Return

`PropList`

==== Example


[source, nix]
.Code
----
removeProp "name" [ { name = "Alice"; } { hobby = "Sports"; } ]

----

[source, nix]
.Result
----
[ {
  hobby = "Sports";
} ]
----






:sectnums:



---




== template




---


:sectnums!:

[[lib.template.documentedTemplate]]
=== documentedTemplate

==== Description

Provide a way to document a template function.

==== Arguments (Attribute Set)


===== arguments

Template arguments documentation. Attrs if the arguments are an attribute set, List for standard arguments.

Type: `Null | Attrs | List`. 

Optional, defaults to `null`.

===== description

Template description, asciidoc markup can be used.

Type: `String`. 

===== env

Template environment.

===== examples

Examples of usages defined with `mkExample`.

Type: `Null | [ Example ]`. 

===== notes

Notes regarding special usages, asciidoc markup can be used.

Type: `Null | String`. 

Optional, defaults to `"Null"`.

===== template

Template to document.

==== Return

The template function, or the documented template set if `env` has a `genDoc` attribute set to `true`.




:sectnums:



---


:sectnums!:

[[lib.template.escapeHTML]]
=== escapeHTML

==== Description

Escape an HTML string.

==== Arguments (Standard)


===== html

A HTML string to escape.

Type: `String`. 

==== Return

The escaped HTML string.

==== Example


[source, nix]
.Code
----
escapeHTML ''<p class="foo">Hello world!</p>''

----

[source, nix]
.Result
----
"&lt;p class=&quot;foo&quot;&gt;Hello world!&lt;/p&gt;"
----






:sectnums:



---


:sectnums!:

[[lib.template.htmlAttr]]
=== htmlAttr

==== Description

Generates a HTML tag attribute.

==== Arguments (Standard)


===== attribute

HTML attribute name.

Type: `String`. 

===== value

HTML attribute value.

Type: `String | [ String ]`. 

==== Return

The HTML attribute string.

==== Example


[source, nix]
.Code
----
htmlAttr "class" "foo"

----

[source, nix]
.Result
----
"class=\"foo\""
----



---

[source, nix]
.Code
----
htmlAttr "class" [ "foo" "bar" ]

----

[source, nix]
.Result
----
"class=\"foo bar\""
----






:sectnums:



---


:sectnums!:

[[lib.template.htmlAttrs]]
=== htmlAttrs

==== Description

Generate a HTML tag attributes.

==== Arguments (Standard)


===== Set

An attribute set where the key is the attribute name, and the value the attribute value(s).

Type: `Attrs`. 

==== Return

The HTML attributes string.

==== Example


[source, nix]
.Code
----
htmlAttrs { class = [ "foo" "bar" ]; }

----

[source, nix]
.Result
----
"class=\"foo bar\""
----



---

[source, nix]
.Code
----
htmlAttrs { class = [ "foo" "bar" ]; id = "baz"; }

----

[source, nix]
.Result
----
"class=\"foo bar\" id=\"baz\""
----






:sectnums:



---


:sectnums!:

[[lib.template.isDocTemplate]]
=== isDocTemplate

==== Description

Check if a set is a documented template.

==== Arguments (Standard)


===== set

Attribute set to check.

Type: `Attrs`. 

==== Return

`Bool`

==== Example





:sectnums:



---


:sectnums!:

[[lib.template.isEven]]
=== isEven

==== Description

Checks if a number is even.

==== Arguments (Standard)


===== a

Number to check.

Type: `Int`. 

==== Return

`Bool`

==== Example


[source, nix]
.Code
----
isEven 3

----

[source, nix]
.Result
----
false
----






:sectnums:



---


:sectnums!:

[[lib.template.isOdd]]
=== isOdd

==== Description

Checks if a number is odd.

==== Arguments (Standard)


===== a

Number to check.

Type: `Int`. 

==== Return

`Bool`

==== Example


[source, nix]
.Code
----
isOdd 3

----

[source, nix]
.Result
----
true
----






:sectnums:



---


:sectnums!:

[[lib.template.mapTemplate]]
=== mapTemplate

==== Description

Concat template functions with a new line.

==== Arguments (Standard)


===== template

The template to apply, must return a string.

Type: `Function`. 

===== items

The items to apply to the template.

Type: `List`. 

==== Return

`String`

==== Example


[source, nix]
.Code
----
mapTemplate (item: ''
  <li>${item}</li>''
) [ "foo" "bar" "baz" ]

----

[source, nix]
.Result
----
"<li>foo</li>
<li>bar</li>
<li>baz</li>"
----






:sectnums:



---


:sectnums!:

[[lib.template.mapTemplateWithIndex]]
=== mapTemplateWithIndex

==== Description

Concat template functions with a new line.

==== Arguments (Standard)


===== template

The template to apply, must return a string.

Type: `Function`. 

===== items

The items to apply to the template.

Type: `List`. 

==== Return

`String`

==== Example


[source, nix]
.Code
----
mapTemplateWithIndex (index: item: ''
  <li>${toString index} - ${item}</li>''
) [ "foo" "bar" "baz" ]

----

[source, nix]
.Result
----
"<li>1 - foo</li>
<li>2 - bar</li>
<li>3 - baz</li>"
----






:sectnums:



---


:sectnums!:

[[lib.template.mod]]
=== mod

==== Description

Returns the remainder of a division.

==== Arguments (Standard)


===== dividend

Dividend.

Type: `Int`. 

===== divisor

Divisor.

Type: `Int`. 

==== Return

Division remainder.

==== Example


[source, nix]
.Code
----
mod 3 2

----

[source, nix]
.Result
----
1
----






:sectnums:



---


:sectnums!:

[[lib.template.normalTemplate]]
=== normalTemplate

==== Description

Abstract the normal template pattern.

==== Arguments (Standard)


===== a

This argument can be:

  * `String`: The argument will be added to the page set `content`.
  * `Attribute Set`: The argument will be merged to the page set.
  * `Page -> String`: The `String` argument will be added to the page set `content` attribute.
  * `Page -> Attrs`: The `Attrs` parameter will be merged to the page set.


==== Return

A normal template function of type `Page -> Page`.

==== Example


[source, nix]
.Code
----
let template = normalTemplate "A simple string.";
    page = { data = "Page data."; };
in template page

----

[source, nix]
.Result
----
{
  content = "A simple string.";
  data = "Page data.";
}
----



---

[source, nix]
.Code
----
let template = normalTemplate { content = "Page content."; };
    page = { data = "Page data."; };
in template page

----

[source, nix]
.Result
----
{
  content = "Page content.";
  data = "Page data.";
}
----



---

[source, nix]
.Code
----
let template = normalTemplate (page: "Page data: ${page.data}");
    page = { data = "Page data."; };
in template page

----

[source, nix]
.Result
----
{
  content = "Page data: Page data.";
  data = "Page data.";
}
----



---

[source, nix]
.Code
----
let template = normalTemplate (page: { title = "foo"; "Page data: ${page.data}"; });
    page = { data = "Page data."; };
in template page

----

[source, nix]
.Result
----
{
  content = "Page data: Page data.";
  data = "Page data.";
  title = "foo";
}
----






:sectnums:



---


:sectnums!:

[[lib.template.parseDate]]
=== parseDate

==== Description

Parse a date.

==== Arguments (Standard)


===== date

A date string in format `"YYYY-MM-DD"` or `"YYYY-MM-DDThh:mm:ss"`

Type: `String`. 

==== Return

A date attribute set, with the following attributes:

* `YYYY`: The year in 4 digit format (2012).
* `YY`: The year in 2 digit format (12).
* `Y`: Alias to `YYYY`.
* `y`: Alias to `YY`.
* `MM`: The month in 2 digit format (12, 01).
* `M`: The month number (12 ,1).
* `m`: Alias to `MM`.
* `m-`: Alias to `M`.
* `B`: Month in text format (December, January).
* `b`: Month in short text format (Dec, Jan).
* `DD`: Day of the month in 2 digit format (01, 31).
* `D`: Day of the month (1, 31).
* `d-`: Alias to `D`.
* `hh`: The hour in 2 digit format (08, 12).
* `h`: The hour in 1 digit format (8, 12).
* `mm`: The minuts in 2 digit format (05, 55).
* `ss`: The seconds in 2 digit format (05, 55).
* `time`: The time in the `mm:hh:ss` format (12:00:00).
* `date.num`: The date in the `YYYY-MM-DD` format (2012-12-21).
* `date.lit`: The date in the `D B YYYY` format (21 December 2012).
* `T`: The date and time combined in the `YYYY-MM-DDThh:mm:ssZ` format (2012-12-21T12:00:00Z).


==== Example


[source, nix]
.Code
----
with (parseDate "2012-12-21"); "${D} ${b} ${Y}"

----

[source, nix]
.Result
----
"21 Dec 2012"
----






:sectnums:



---


:sectnums!:

[[lib.template.processBlocks]]
=== processBlocks

==== Description

Merge blocks data.

==== Arguments (Standard)


===== blocks

List of blocks attributes set

Type: `[ Block ]`. 

==== Return

`Block`

==== Example


[source, nix]
.Code
----
processBlocks [ {
  content = "Block A";
  extraJS = "js/a.js";
} {
  content  = "Block B";
  extraJS  = "js/b.js";
  extraCSS = "css/b.css";
} {
  content  = "Block C";
  extraCSS = "css/c.css";
} {
  content  = "Block D";
  extraJS  = [ "js/d.js"   "js/d-1.js" ];
  extraCSS = [ "css/d.css" "css/d-1.css" ];
} ]

----

[source, nix]
.Result
----
{
  content = "Block A
Block B
Block C
Block D";
  extraCSS = [ "css/b.css" "css/c.css" "css/d.css" "css/d-1.css" ];
  extraJS = [ "js/a.js" "js/b.js" "js/d.js" "js/d-1.js" ];
}
----






:sectnums:



---




== themes




---


:sectnums!:

[[lib.themes.docText]]
=== docText

==== Description

Convert a documentation set to a property list to generate documention.

==== Arguments (Standard)


===== doc

Documentation set.

Type: `Attrs`. 

==== Return

A prepared documentation property list.

==== Example


[source, nix]
.Code
----
docText (mkDoc {
  title = mkOption {
    description = "Title";
    type = types.str;
  };
  foo.bar = 1;
})

----

[source, nix]
.Result
----
[ {
  "foo.bar" = {
    default = 1;
  };
} {
  title = {
    description = "Title";
    type = "string";
  };
} ]
----






:sectnums:



---


:sectnums!:

[[lib.themes.load]]
=== load

==== Description

Load themes data.


==== Arguments (Attribute Set)


===== decls

A declaration set to merge into to themes configuration.

Type: `Attrs`. 

Optional, defaults to `[  ]`.

===== env

An attribute set to merge to the environment, the environment is used in templates and returned in the `env` attribute.

Type: `Attrs`. 

Optional, defaults to `{ }`.

===== lib

The styx library.

Type: `Attrs`. 

===== themes

List of themes, local themes or packages.

Type: `[ (Path | Package) ]`. 

Optional, defaults to `{ }`.

==== Return

A theme data attribute set containing:

* `conf`: Themes configuration merged with `extraConf`.
* `lib`: The merged themes library.
* `files`: List of static files folder.
* `templates`: The merged themes template set.
* `themes`: List of themes attribute sets.
* `decls`: Themes declaration set.
* `docs`: Themes documentation set.
* `env`: Generated environment attribute set, `extraEnv` merged with `lib`, `conf` and `templates`.


==== Example


[source, nix]
.Code
----
themesData = lib.themes.load {
  inherit lib themes;
  env  = { inherit data pages; };
  decls = lib.utils.merge [
    (import ./conf.nix {/* ... */})
    extraConf
  ];
};

----






:sectnums:



---


:sectnums!:

[[lib.themes.loadData]]
=== loadData

==== Description

Load a theme data.


==== Arguments (Attribute Set)


===== lib

The styx library.

Type: `Attrs`. 

===== theme

A local theme or theme package.

Type: `(Path | Package)`. 

==== Return

A theme data attribute set containing:

* `lib`: Theme library set.
* `meta`: Theme meta information set.
* `path`: Path of the theme.
* `decls`: Theme declaration set, only if the theme defines a configuration interface.
* `docs`: Theme documentation set, only if the theme defines a configuration interface.
* `exampleSrc`: Theme example site source, only if the theme provides an example site.
* `templates`: Theme templates set, only if the theme provides templates.
* `files`: Theme static files path, only if the theme provides static files.






:sectnums:



---


:sectnums!:

[[lib.themes.mkDoc]]
=== mkDoc

==== Description

Convert a theme declaration set to a documentation set.


==== Arguments (Standard)


===== decls

Theme declarations set.

Type: `Attrs`. 

==== Return

A documentation set.

==== Example


[source, nix]
.Code
----
mkDoc {
  foo.bar = 1;
  title = mkOption {
    description = "Title";
    type = types.str;
  };
}

----

[source, nix]
.Result
----
{
  foo = {
    bar = {
      _type = "option";
      default = 1;
    };
  };
  title = {
    _type = "option";
    description = "Title";
    type = "string";
  };
}
----






:sectnums:



---




== utils

This namespace contains generic functions.



---


:sectnums!:

[[lib.utils.chunksOf]]
=== chunksOf

==== Description

Split a list in lists multiple lists of `size` items.

==== Arguments (Standard)


===== size

Maximum size of the splitted lists.

Type: `Integer`. 

===== list

List to split.

Type: `List`. 

==== Return

A list of lists of `size` size.


==== Example


[source, nix]
.Code
----
chunksOf 2 [ 1 2 3 4 5 ]
----

[source, nix]
.Result
----
[ [ 1 2 ] [ 3 4 ] [ 5 ] ]
----






:sectnums:



---


:sectnums!:

[[lib.utils.dirContains]]
=== dirContains

==== Description

Check if a path exists in a directory.






:sectnums:



---


:sectnums!:

[[lib.utils.documentedFunction]]
=== documentedFunction

==== Description

Create a documented function. A documented function is used to automatically generate documentation and tests.

==== Arguments (Attribute Set)


===== arguments

Function arguments documentation. Attrs if the arguments are an attribute set, List for standard arguments.

Type: `Null | Attrs | List`. 

Optional, defaults to `null`.

===== description

Function description, asciidoc markup can be used.

Type: `String`. 

===== examples

Examples of usages defined with `mkExample`.

Type: `Null | [ Example ]`. 

===== function

The function to document.

===== notes

Notes regarding special usages, asciidoc markup can be used.

Type: `Null | String`. 

Optional, defaults to `"Null"`.

===== return

Description of function return value, asciidoc markup can be used.

Type: `String`. 

==== Return

The documented function set.




:sectnums:



---


:sectnums!:

[[lib.utils.find]]
=== find

==== Description

Find a set in a list of set matching some criteria.

==== Arguments (Standard)


===== criteria

Criteria to find as an attribute set, can be a value to be compared or a function to compare the value.

Type: `Attrs`. 

===== list

List of attributes to lookup for `criteria`.

Type: `Attrs`. 

==== Return

The first matched attribute set, or throw an error if no result has been found.

==== Example


[source, nix]
.Code
----
find { uid = "bar"; } [ 
  { uid = "foo"; }
  { uid = "bar"; content = "hello!"; }
  { uid = "baz"; }
]

----

[source, nix]
.Result
----
{
  content = "hello!";
  uid = "bar";
}
----



---

[source, nix]
.Code
----
find { number = (x: x > 3); color = "blue"; } [
  { number = 1; color = "blue"; }
  { number = 4; color = "red"; }
  { number = 6; color = "blue"; }
]

----

[source, nix]
.Result
----
{
  color = "blue";
  number = 6;
}
----






:sectnums:



---


:sectnums!:

[[lib.utils.getAttrs]]
=== getAttrs

==== Description

Get the attribute values for the `n` attribute name from a `l` list of attribute sets.

==== Arguments (Standard)


===== n

Attribute name.

Type: `String`. 

===== l

List of attribute sets.

Type: `[ Attrs ]`. 

==== Return

A list containing the values of `n`.


==== Example


[source, nix]
.Code
----
getAttrs "a" [ { a = 1; } { a = 2; } { b = 3; } { a = 4; } ]
----

[source, nix]
.Result
----
[ 1 2 4 ]
----






:sectnums:



---


:sectnums!:

[[lib.utils.importApply]]
=== importApply

==== Description

Import a nix file `file` and apply the arguments `arg` if it is a function.

==== Arguments (Standard)


===== file

Nix file to load.

Type: `Path`. 

===== arg

Argument to call `file` contents with if it is a function.





:sectnums:



---


:sectnums!:

[[lib.utils.is]]
=== is

==== Description

Check if an attribute set has a certain type.

==== Arguments (Standard)


===== type

Type to check.

Type: `String`. 

===== attrs

Attribute set to check.

Type: `Attrs`. 

==== Return

`Bool`

==== Example


[source, nix]
.Code
----
is "foo" { _type = "foo"; }

----

[source, nix]
.Result
----
true
----






:sectnums:



---


:sectnums!:

[[lib.utils.isDocFunction]]
=== isDocFunction

==== Description

Check if a set is a documented fuction.

==== Arguments (Standard)


===== attrs

Attribute set to check.

Type: `Attrs`. 

==== Return

`Bool`




:sectnums:



---


:sectnums!:

[[lib.utils.isExample]]
=== isExample

==== Description

Check if a set is an example.

==== Arguments (Standard)


===== attrs

Attribute set to check.

Type: `Attrs`. 


==== Example


[source, nix]
.Code
----
isExample (mkExample {
  literalCode = "2 + 2";
  code = 2 + 2;
})

----

[source, nix]
.Result
----
true
----






:sectnums:



---


:sectnums!:

[[lib.utils.isPath]]
=== isPath

==== Description

Check if the parameter is a path






:sectnums:



---


:sectnums!:

[[lib.utils.merge]]
=== merge

==== Description

Merge recursively a list of sets.



==== Example


[source, nix]
.Code
----
conf = lib.utils.merge [
  (lib.themes.loadConf { inherit themes; })
  (import ./conf.nix)
  extraConf
];

----



---

[source, nix]
.Code
----
merge [ { a = 1; b = 2; } { b = "x"; c = "y"; } ]

----

[source, nix]
.Result
----
{
  a = 1;
  b = "x";
  c = "y";
}
----






:sectnums:



---


:sectnums!:

[[lib.utils.mkExample]]
=== mkExample

==== Description

Create an example set.


==== Return

An example attribute set.




:sectnums:



---


:sectnums!:

[[lib.utils.prettyNix]]
=== prettyNix

==== Description

Pretty print nix values.



==== Example


[source, nix]
.Code
----
prettyNix [ { a.b.c = true; } { x.y.z = [ 1 2 3 ]; } ]

----

[source, nix]
.Result
----
"[ {
  a = {
    b = {
      c = true;
    };
  };
} {
  x = {
    y = {
      z = [ 1 2 3 ];
    };
  };
} ]"
----






:sectnums:



---


:sectnums!:

[[lib.utils.setToList]]
=== setToList

==== Description

Convert a deep set to a list of sets where the key is the path.



==== Example


[source, nix]
.Code
----
setToList { a.b.c = true; d = "foo"; x.y.z = [ 1 2 3 ]; }

----

[source, nix]
.Result
----
[ {
  "a.b.c" = true;
} {
  d = "foo";
} {
  "x.y.z" = [ 1 2 3 ];
} ]
----






:sectnums:



---


:sectnums!:

[[lib.utils.sortBy]]
=== sortBy

==== Description

Sort a list of attribute sets by attribute.



==== Example


[source, nix]
.Code
----
sortBy "priority" "asc" [ { priority = 5; } { priority = 2; } ]

----

[source, nix]
.Result
----
[ {
  priority = 2;
} {
  priority = 5;
} ]
----






:sectnums:



---




