[[Pages]]
== Pages

Pages are declared in a `pages` an attribute set. Every page or list of pages declared in this set will be generated.


=== Overview

Pages are passed to the `generateFunction` through the `pagesList` argument that turn each page into a text file.

TIP: Pages are usually generated as html documents, but any kind of text file can be generated from a page attribute set.


=== The page attribute set

The page attribute set is an attribute set that must defines at least three attributes:

* `layout`: A function that take the `template` result as a parameter and return the source of the file to generate.
* `template`: A function that take the page attribute set as a parameter and returns an updated attribute set.
* `path`: The path of the page to generate, must start with a `/`.

NOTE: These attributes are the strict minimum, but many templates will require extra attributes like `content` or `title`.

IMPORTANT: `path` must start with a `/`, else site generation will fail.

<<Hello world!>> contains an example of a simple page attribute set.

[source, nix]
.Simple page attribute set
----
pages.index = {
  path     = "/index.html";
  layout   = template: "<html><body>${template}</body></html>";
  template = page: "<h1>Hello world!</h1>";
};
----

In an standard `site.nix`, `template` and `layout` would be attributes from the `templates` set like `templates.page.full` or `templates.layout`.

Page attribute sets are often augmented by various attributes or merged with data sets.

NOTE: `generateSite` evaluate `page.layout (page.template page)` and output the result in `page.path` for every page in its `pagesList` argument.

TIP: As many pages tends to use the same layout, the `layout` attribute is usually set in one go to all templates in the "site" section with <<lib.generation.pagesToList,lib.generation.pagesToList>> `default` parameter. +
Usually, only pages that use a different layout explicitly declares it in `pages`. +
The following examples will omit the `layout` attribute like often done in a normal `site.nix`.


=== Simple pages

Generating a simple page is trivial as it is just declaring the required attributes.

[source, nix]
.Creating an error 404 page
----
pages.e404 = {
  path     = "/404.html";
  template = templates.e404;
};
----

NOTE: Attribute set attributes should not start with a number. That is why the 404 template is `templates.e404` and not `templates.404`. +
Nix allow to use attributes starting with a number, but they must be called by using `"`. This is error prone and not used in styx.

=== Attaching data to a page

Generating a page from an imported data is a very common case, and can be done with the `//` operator.

[source, nix]
.Attaching a data set to a page attribute set.
----
pages.about = {
  path     = "/about.html";
  template = templates.page.full;
} // data.about;
----

The `//` operator will merge the `data.about` data set in the `pages.about` page set.


=== Bypassing the layout

For pages which the template generate the full page source like for RSS feeds, applying a layout is not needed. +
In such cases, the `lib.id` function, a function that return its parameter without changing it can be used as a "transparent" layout.

[source, nix]
.Using id as a layout
----
pages.feed = {
  path     = "/feed.xml";
  template = templates.feed.atom;
  items    = lib.take 10 posts;
  layout   = lib.id;
};
----

NOTE: The `id` function is defined as `x: x`.

=== Split pages

Split pages refers to a list of data split though multiple similar pages.

A common example of split page is a blog archive page, where the posts are listed through multiple pages.

Split pages can be generated with the <<lib.pages.mkSplit>> or <<lib.pages.mkSplitCustom>> function. +
`mkSplit` being a simpler version of `mkSplitCustom` function that should fit most of needs.

[source, nix]
.mkSplit example
----
pages.archives = lib.mkSplit {
  basePath     = "/archives";
  template     = templates.archives;
  itemsPerPage = 5;
  data         = pages.posts;
};
----

This will create a list of pages attribute sets with the following extra attributes:

`path`:: Set accordingly to `basePath`. `basePath.html` for the first page, and `basePath-i.html` for the following pages where `i` is the index of the page.
`items`:: The list of items for this page.
`index`:: The position of this page in the list of split pages.
`pages`:: The split pages lists, useful for generating a pagination.

For more complex splitting needs see the <<lib.pages.mkSplitCustom>> function documentation.

NOTE: `mkSplit` only requires `basePath`, `itemsPerPage` and `data` as parameters. Any extra parameter passed will be added to every split page attribute set. +
This is on purpose and is used in the previous example to set all the split pages template in the `mkSplit` declaration.


=== Multipages

Multipages are page attribute sets that have a `pages` attribute containing a list of pages in the `pages` attribute set.

Multipages are usually generated by importing <<data.multipage>>, data attribute set with a `pages` attribute.

Multipage pages are referred as:

* `all`: The full subpages list.
* `head`: First page in the subpages list.
* `tail`: All the subpages, but the first.

==== Single page

Multipages can be generated with the <<lib.pages.mkMultipages>> function.

[source, nix]
.mkMultipages example
----
pages.about = lib.mkMultipages ({
  template = templates.page.full;
  basePath = "/about";
} // data.about);
----

NOTE: `mkMultipages` only requires `basePath` and `pages` as parameters. Any extra parameter passed will be added to every generated attribute attribute set.


==== Pages in a list

For a list of pages that might contains multipages, the problem is different.

If `mkMultipages` is naively used, every multipage page will end up in the page list, and it is not what is expected most of the time.

If we have a list of posts, and some are multipages, we want the `pages.posts` list of pages to include single page posts and the first page of multipages post. +
That way, multipage post subpages will not end up in posts archives list or in the web feed.

So for multipages in a list, the generation will be separated in two steps.

1. Generate the page list with single page data and multipage first page data.
2. Generate the multipage subpages data.

---

First step, generate the page set list with single page data and multipage first page data.

This could be done using `mkMultipages` and filtering / mapping, but a <<lib.pages.mkPageList>> function is available and do exactly that.

[source, nix]
.Generating the page list with multipage head pages
----
pages.posts = lib.mkPageList {
  data     = data.posts; # <1>
  template = templates.post.full;
};
----

<1> `data` is a list of data attribute set to generate pages attribute set from.

It is possible to render multiPages with a different template by setting the `multipageTemplate` parameter.

---

Next step is to generate the `tail` of the multipages posts.

<<lib.pages.mkMultiTail>> is a function that generate page sets for the multipages `tail` in a list of data sets.

[source, nix]
.Generating the multipage posts tail
----
pages.multiPostsTail = lib.mkMultiTail {
  data     = data.posts;
  template = templates.post.full-multipage;
};
----

This is very similar to the `mkPageList` function but only tail pages sets are generated. As only tail pages are rendered, the template is directly set with the `template` attribute.

IMPORTANT: It is possible to set a prefix to the generated `path` attribute of <<lib.pages.mkPageList>> and <<lib.pages.mkMultiTail>> function with the `pathPrefix` argument. +
If the `pathPrefix` argument is set, it **must** be the same for the same data set, else the links between `head` and `tail` pages will be broken.

=== Taxonomy pages

NOTE: To see how to generate taxonomy data, refer to <<Taxonomies>>.

Taxonomies pages can be generated from a taxonomy data structure with the <<lib.pages.mkTaxonomyPages>> function.

[source, nix]
----
taxonomies = lib.mkTaxonomyPages {
  data = data.taxonomies;
  taxonomyTemplate = templates.taxonomy.full;
  termTemplate = templates.taxonomy.term.full;
};
----

The <<lib.pages.mkTaxonomyPages>> function will create the following page attribute sets:

- `TAXONOMY/index.html`, the taxonomy index page set for every taxonomy. A `terms` attribute will be added to the page attribute set containing all the taxonomy terms.
- `TAXONOMY/TERM/index.html`, the term index page set for every term in every taxonomy. A `values` attribute will be added to the page attribute set containing all the values that use the term.

NOTE: If required `mkTaxonomyPages` generated pages `path` can be changed with the `taxonomyPathFun` and the `termPathFun`, for details see <<lib.pages.mkTaxonomyPages>>. +
If any of these functions is changed, the templates should be updated accordingly.

